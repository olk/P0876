\newpage
\abschnitt{Wording}\label{api}

This wording is relative to N4964.\cite{Standard}

\bfs{Append} to §6.9.2.1 \stdclause{intro.multithread.general} as indicated:

\setcounter{section}{6}
\setcounter{subsection}{9}
\setcounter{subsubsection}{2}
\setcounter{secnumdepth}{4}

3 A \emph{processor thread} is the default thread of execution on
which \main is entered, or the thread of execution created by \thread
(\stdclause{thread.thread.class}), or the thread of execution created
by \jthread (\stdclause{thread.jthread.class}).

4 A \emph{fiber} is a thread of execution with weakly parallel forward
progress guarantees (\stdclause{intro.progress} paragraph 11).

5 A \emph{function call stack} represents the invocation sequence
(\stdclause{stacktrace.general} paragraph 2) of every evaluation in the thread
of execution.

6 Each fiber has a one-to-one association with a function call stack.
Calling functions on a particular fiber, and returning from them, is
independent of function calls and returns on any other fiber.

7 The default thread of execution on which \main is entered has an
initial \emph{default fiber} whose function call stack is the stack on
which \main is entered. \tsnote{Thus, when \main creates a new fiber, it
becomes the second fiber in the program.}
Similarly, every explicitly-created \thread or \jthread has an initial default
fiber whose function call stack is the stack on which the function passed to
the respective constructor is entered.

8 A new fiber may be explicitly created (\stdclause{fibercontext}).
\emph{explicit fiber} or \emph{explicitly-launched fiber} designates a fiber
created by program evaluation; conversely, \emph{implicit fiber} designates
the default fiber on any processor thread.

9 On entry, a processor thread blocks with forward progress guarantee
delegation (\stdclause{intro.progress} paragraph 14) on its default fiber. The
running fiber may block with forward progress guarantee delegation on another
fiber.

\bfs{Modify} §6.9.2.2 \stdclause{intro.races} paragraph 2 as indicated:

Two expression evaluations \emph{conflict} if \add{ they are running on distinct
threads of execution with forward progress guarantees}\\
\add{stronger than weakly parallel, and} one of them modifies a memory location
(\stdclause{intro.memory}) and the other one reads or modifies the same memory
location. \add{\enternote If either thread of execution has weakly parallel forward
progress guarantees,}\\
\add{it does not conflict with the other. \exitnote}

\bfs{Append} to §14.4.8 \stdclause{except.handle} as indicated:

\add{It is implementation-defined whether the currently handled exception
designates the exception with the most recently}\\
\add{activated handler that is still active within:}
\begin{itemize}
    \item \add{the current thread of execution, or}
    \item \add{the current \thread.}
\end{itemize}

\bfs{Append} to §14.6.3.1 \stdclause{except.uncaught} as indicated:

\add{It is implementation-defined whether \cpp{uncaught\_exceptions()} returns
the number of uncaught exceptions in:}
\begin{itemize}
    \item \add{the current thread of execution, or}
    \item \add{the current \thread.}
\end{itemize}

\bfs{Insert} new final subclause in clause 33 \stdclause{thread} as indicated:

\setcounter{section}{33}
\setcounter{subsection}{11}
\setcounter{secnumdepth}{4}

\rSec2[fibercontext]{Cooperative Threads}

\rSec3[fibercontext.general]{General}

\para A fiber is a thread of execution (\stdclause{intro.multithread.general}) with
weakly parallel forward progress guarantees (\stdclause{intro.progress} paragraph 11).

\para The term \emph{cooperative} means that typically multiple fibers share a
given processor thread. On the underlying processor thread, only one fiber is
running at any given time. Sharing that processor thread is explicit rather
than pre-emptive. The running fiber \emph{suspends}, or \emph{yields} to
another fiber. This action enters a newly created fiber, or \emph{resumes} a
previously-suspended fiber.

\para Suspending the running fiber in order to resume (or enter) another is
called \emph{context switching}. This is an explicit case of blocking with
forward progress guarantee delegation (\stdclause{intro.progress} paragraph 14).

\rSec3[fibercontext.empty]{Empty vs. Non-Empty}

\para A \fiber instance is either \emph{empty} or \emph{non-empty}. A
default-constructed \fiber is empty. A moved-from \fiber is empty. A \fiber
representing a suspended fiber is non-empty.

\para When the running fiber returns a \fiber from its \entryfn, thus resuming the
designated fiber, the synthesized \fiber passed into the resumed fiber is
empty.

\para An explicit fiber is instantiated by passing an \emph{\entryfn} to \fiber's
constructor. This function is not entered until the first call to one of
the \cpp{fiber\_context::resume()} family of methods.

\begin{itemize}
    \item An implicit fiber's \emph{owning thread} is the thread of which that
          fiber is the default fiber.
    \item An explicit fiber initially has no owning thread.
    \item When some thread first calls \anyresume on an explicit fiber, that
          thread becomes the fiber's owning thread.
\end{itemize}

\para When a fiber is first entered, a synthesized non-empty \fiber instance
representing the newly-suspended previous fiber is passed as a parameter to
its \entryfn. Once entered, a fiber may suspend by calling one of the \resume
family of methods on any available non-empty \fiber instance. When the
suspended fiber is resumed, that method returns a synthesized \fiber instance
representing the newly-suspended previous fiber.

\para The synthesized \fiber instance received in either of those ways might
represent either an explicit fiber or an implicit fiber.

\para An explicit fiber terminates by returning from its \entryfn. If the \entryfn
returns a non-empty \fiber instance, \thefiber{that \fiber instance} is resumed.

%% \rSec3[fibercontext.toplevel]{Implicit Top-Level Function}

%% On every explicit fiber, the behaviour is equivalent to calling the \entryfn
%% passed to \fiber's constructor from an implicit top-level function.
%% If the fiber is later
%% unwound, this conceptual top-level stack frame serves as delimiter: this point
%% is where unwinding stops.

\para If the fiber's \entryfn exits via an exception, \cpp{std::terminate} is called.

%% Returning a \fiber instance from the explicit fiber's \entryfn is equivalent
%% to returning control to the implicit top-level function.
%% Similarly,
%% when \unwindfib unwinds a fiber stack, it conceptually returns the \fiber
%% instance it was passed to the implicit top-level function. Either way, the
%% The
%% conceptual implicit top-level function is responsible for deallocating the
%% explicit fiber's stack memory on return from the \entryfn.
%% 
%% Similarly, on every implicit fiber, the behaviour is equivalent to passing control through an
%% implicit top-level function above \main and above the \entryfn for
%% each \thread.
%% The conceptual stack frame for this implicit top-level function delimits
%% stack unwinding for each of these stacks. If the fiber stack is unwound,
%% control is conceptually returned to this implicit top-level function.
%% The conceptual top-level
%% function for an implicit fiber does not deallocate the fiber's stack memory,
%% since the host environment will do that.

%% \begin{itemize}
%%     \item
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function for an explicit fiber, the calling thread is terminated.
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function for the default fiber of an explicit thread, that thread is
%%     terminated.
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function above \main, the process is terminated.
%% \end{itemize}

%--------------------------------- synopsis ----------------------------------
\rSec3[fibercontext.syn]{Header <fiber\_context> synopsis}

\cppf{synopsis}

%--------------------------------- class def ---------------------------------
\rSec3[fibercontext.class]{Class fiber\_context}

\cppf{fiber}

\newcommand{\state}{\cpp{state}}

\rSec4[fibercontext.cons]{Constructors, move and assignment}
%------------------------------- nullary ctor --------------------------------
\mbrhdr{fiber\_context() noexcept}\label{constructor}

\effects
instantiates an empty \fiber.

\postcond
\emptyfn is \true.

%---------------------------- implicit stack ctor ----------------------------
\mbrhdr{template<class F> explicit fiber\_context(F\&\& entry)}

\constraints
\cpp{remove\_cvref\_t<F>} is not the same type as \fiber.

\mandates
\begin{description}
    \item[---] \cpp{is\_constructible\_v<decay\_t<F>, F>} is \true.
    \item[---] \cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<F>,
               fiber\_context&&>} is \true.
\end{description}

\precond
\cpp{F} meets the \emph{Cpp17CopyConstructible} requirements.

\para Let \cpp{entry\_copy} be state associated with the new fiber
that is not a data member of \fiber. \tsnote{\cpp{entry\_copy}
could be stored at the base of the new fiber's stack.}

\effects
\begin{description}
    \item[---] Initializes \cpp{entry\_copy} with \emph{decay-copy}\cpp{(std::forward<F>(entry))}.
    \item[---] Initializes \cpp{state} to represent a fiber suspended before
              entry to \cpp{entry\_copy}.
              \tsnote{\cpp{entry\_copy} is entered only when \anyresume is called.}
    \item[---] The new fiber's function call stack and any other necessary
              resources are created.
\end{description}

\postcond
\emptyfn is \false.

\except
\begin{description}
    \item[---] \cpp{bad\_alloc} if unable to acquire a new function call stack.
    \item[---] \cpp{system\_error} if unable to start the new fiber.
    \item[---] Any exception thrown by the selected constructor of \cpp{entry}.
\end{description}

\errors
\cpp{resource\_unavailable\_try\_again} -- the system lacked the necessary resources to create another fiber.

%---------------------------- explicit stack ctor ----------------------------
\mbrhdr{template<class F, class D> fiber\_context(F\&\& entry, span<byte> stack, D\&\& deleter)}

\mandates
\begin{description}
    \item[---] \cpp{is\_constructible\_v<decay\_t<F>, F>} is \true.
    \item[---] \cpp{is\_constructible\_v<decay\_t<D>, D>} is \true.
    \item[---] \cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<F>,
               fiber\_context&&>} is \true.
    \item[---] \cpp{is\_invocable\_v<decay\_t<D>, span<byte>>} is \true.
\end{description}

\precond
\begin{description}
    \item[---] \cpp{F} meets the \emph{Cpp17CopyConstructible} requirements.
    \item[---] \cpp{D} meets the \emph{Cpp17CopyConstructible} requirements.
\end{description}

\para Let \cpp{entry\_copy}, \cpp{stack\_copy}
and \cpp{deleter\_copy} be state associated with the new fiber
that are not data members of \fiber. \tsnote{\cpp{entry\_copy},
\cpp{stack\_copy} and \cpp{deleter\_copy} could be stored at
the base of the new fiber's stack.}

\effects
\begin{description}
    \item[---] Initializes \cpp{entry\_copy} with \emph{decay-copy}\cpp{(std::forward<F>(entry))}.
    \item[---] Initializes \cpp{stack\_copy} with \emph{decay-copy}\cpp{(std::forward<F>(stack))}.
    \item[---] Initializes \cpp{deleter\_copy} with \emph{decay-copy}\cpp{(std::forward<F>(deleter))}.
    \item[---] Initializes \cpp{state} to represent a fiber suspended before
              entry to \cpp{entry\_copy}.
              \tsnote{\cpp{entry\_copy} is entered only when \anyresume is called.}
    \item[---] The contiguous block of uninitialized memory referenced
              by \cpp{stack} is prepared as the new fiber's function call stack.
              \tsnote{It is the caller's responsibility to provide a span of
              sufficient size for the most deeply nested function calls that
              will be performed by the new fiber. It may be advantageous to
              obtain from the operating system a memory block with a read-only
              guard page to trap stack overflow.}
              Any other necessary resources are created.
\end{description}

\postcond
\emptyfn is \false.

\except
\begin{description}
    \item[---] \cpp{invalid\_argument} if \cpp{stack} fails to meet
               implementation-defined alignment requirements.
    \item[---] \cpp{length\_error} if \cpp{stack} is less than the
               implementation-defined minimum length.
    \item[---] \cpp{system\_error} if unable to start the new fiber.
    \item[---] Any exception thrown by the selected constructor of \cpp{entry}.
    \item[---] Any exception thrown by the selected constructor of \cpp{deleter}.
\end{description}

\errors
\cpp{resource\_unavailable\_try\_again} -- the system lacked the necessary resources to create another fiber.

\remarks
If at any time during the life of the newly created fiber the
function call stack depth exceeds the size of \cpp{stack}, the behaviour is
undefined.

%--------------------------------- move ctor ---------------------------------
\mbrhdr{fiber\_context(fiber\_context\&\& other) noexcept}

\effects
Initializes \cpp{state} with \cpp{exchange(other.state, nullptr)}.

\postcond
\cpp{other.}\emptyfn is \true.

%----------------------------------- dtor ------------------------------------
\mbrhdr{\cpp{\~fiber\_context()}}

\effects
If \emptyfn is \false, \cpp{terminate} is invoked (\stdclause{except.terminate}).

\tsnote{If a \fiber instance to be destroyed is not yet empty, an application
must convey to the suspended fiber the need to terminate voluntarily.}

%------------------------------ move assignment ------------------------------
\mbrhdr{fiber\_context\& operator=(fiber\_context\&\& other) noexcept}

\effects
\begin{description}
    \item[---] If \emptyfn is \false, \cpp{terminate} is invoked (\stdclause{except.terminate}).
    \item[---] Equivalent to: \cpp{this->state = exchange(other.state, nullptr)}.
\end{description}

\returns
\this

\postcond
\cpp{other.}\emptyfn is \true

\rSec4[fibercontext.mem]{Members}
%-------------------------------- resume_with --------------------------------
\mbrhdr{template<class Fn> fiber\_context resume\_with(Fn\&\& fn) \&\&}

\mandates
\cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<Fn>, fiber\_context&&>}

\precond
\canresume is \true

\newcommand{\continuation}{\cpp{continuation}}

\para Let \cpp{target} be \thefiber{\state}.
\para Let \cpp{caller} be a synthesized \fiber instance representing
the suspended calling fiber.

\effects
\begin{description}
    \item[---] Resets \state so that \emptyfn is \true.
    \item[---] Blocks with forward progress guarantee delegation \stdclause{intro.progress}
               on \cpp{target}.
    \item[---] Evaluates \cpp{invoke(std::forward<Fn>(fn), std::move(caller))}
               on fiber \cpp{target}.
               Let \cpp{returned} be the \fiber instance returned by \cpp{fn}.
               \tsnote{\cpp{returned} may or may not be the same as \cpp{caller}.}
               \tsnote{\cpp{returned} may be empty.}
    \item[---] If \cpp{target} has not previously been
               entered, passes \cpp{returned} to its \entryfn. Let \continuation
               be the result of executing
               \cpp{invoke\_r<fiber\_context>(entry\_copy, std::move(returned))}. On return:
        \begin{itemize}
            \item restores the execution context of \continuation
            \item destroys \cpp{entry\_copy}
            \item if \cpp{target} has an associated \cpp{stack\_copy} and \cpp{deleter\_copy}:
                \begin{itemize}
                    \item executes \cpp{invoke(deleter\_copy, stack\_copy)}
                    \item destroys \cpp{deleter\_copy}
                \end{itemize}
            \item otherwise reclaims the implementation-provided stack
            \item resumes \continuation as if by \cpp{continuation.resume()}.
        \end{itemize}
    \item[---] Otherwise, \cpp{target} previously
               suspended itself by calling one of \anyresume.
               Returns \cpp{returned} from that resume function.
\end{description}

\remarks
A newly constructed but not yet resumed fiber may be resumed by
any thread.

\returns
\begin{description}
    \item[---] If the previous fiber resumed this one by returning a \fiber,
               an empty \fiber.
    \item[---] If the previous fiber resumed this one by passing some \cpp{fn}
               to \anyresumewith, the \fiber returned by that \cpp{fn}.
\end{description}

\except
\begin{description}
%   \item[---] \anyresume throws
%             \unwindex when, while suspended, the \fiber instance representing
%             the suspended fiber is destroyed
    \item[---] Nothing before suspending the calling fiber and
               ensuring \emptyfn is \true.
    \item[---] On being resumed:
    \begin{itemize}
        \item If the previous fiber resumed this one by returning a \fiber:
            \begin{itemize}
                \item Any exception thrown as a result of destroying the
                      previous fiber's associated \cpp{entry\_copy}.
                \item Any exception thrown by the previous fiber's
                      associated \cpp{deleter\_copy}.
                \item Any exception thrown as a result of destroying the
                      previous fiber's associated \cpp{deleter\_copy}.
            \end{itemize}
        \item If the previous fiber resumed this one by calling \anyresumewith:
        \begin{itemize}
            \item Any exception thrown by the \cpp{fn} passed by the previous
                  fiber to \anyresumewith.
        \end{itemize}
    \end{itemize}
\end{description}

\postcond
\emptyfn is \true.

\tsnote{The returned \fiber indicates via \emptyfn whether the previous active
fiber has terminated (returned from \entryfn).}

\tsnote{\anyresume empties the instance on which it is called. In order to
express the state change explicitly, these methods are rvalue-reference
qualified. For this reason, no \fiber instance ever represents the
currently-running fiber.}

%---------------------------------- resume -----------------------------------
\mbrhdr{fiber\_context resume() \&\&}

\effects
Equivalent to:\\
\cpp{return resume\_with([](fiber\_context&& caller)\{ return std::move(caller); \});}

%-------------------------------- can_resume ---------------------------------
\mbrhdr{bool can\_resume() noexcept}

\returns
\begin{description}
    \item[---] \false if \emptyfn is \true
    \item[---] \true if \thisfiber has no owning thread
    \item[---] \true if \currthread is \ownthread
    \item[---] \false otherwise.
\end{description}

\tsnote{When \canresume is \true, the \fiber instance may be resumed
by \anyresume.}

\EnterBlock{Editorial note} \canresume is intentionally not
marked \cpp{const}. \ExitBlock{editorial note}

%----------------------------------- empty -----------------------------------
\mbrhdr{bool empty() const noexcept}

\returns
Equivalent to: \cpp{(\! state)}.

\tsnote{Regardless of the number of \fiber declarations, exactly one
\fiber instance represents each suspended fiber.}

%------------------------------- operator bool -------------------------------
\mbrhdr{explicit operator bool() const noexcept}

\effects
Equivalent to: \cpp{(\! empty())}.

%----------------------------------- swap ------------------------------------
\mbrhdr{void swap(fiber\_context\& other) noexcept}

\effects
Equivalent to: \cpp{swap(this->state, other.state)}.

\rSec4[fibercontext.special]{Specialized algorithms}
\mbrhdr{friend void swap(fiber\_context\& lhs, fiber\_context\& rhs) noexcept}

\effects
Equivalent to: \cpp{lhs.swap(rhs)}.


%% \rSec3[fibercontext.unwinding]{Function unwind\_fiber()}
%% 
%% \mbrhdr{[[ noreturn ]] void unwind\_fiber(fiber\_context\&\& other)}
%% 
%% \effects
%% terminate the current running fiber.
%% 
%% \remarks
%% \begin{description}
%%     \item[---] The underlying Unwinding facility (for instance the unwind facility
%%                described in \emph{System V ABI for AMD64}) unwinds the stack
%%                to the implicit top-level stack frame and terminates the
%%                current fiber as described above.
%%     \item[---] Unwinding the fiber's stack causes its stack variables to be
%%                destroyed.
%%     \item[---] During this specific stack unwinding, 
%% %% only \catchall clauses are executed. No other
%%                no \cpp{catch} clauses are executed, not even \catchall.
%%     \item[---] Once the running fiber has been fully unwound, \cpp{other} is
%%                returned to the fiber's conceptual top-level function as
%%                described in \nameref{fiber-context.toplevel}.
%% %%  \item[---] Unwinding the fiber's stack causes relevant \catchall
%% %%             clauses to be executed.
%% %%  \item[---] During this specific stack unwinding, a \catchall
%% %%             clause that does not execute a \cpp{throw;} statement behaves
%% %%             as if it ended with a \cpp{throw;} statement.
%% %%  \item[---] During this specific stack unwinding, if a \catchall
%% %%             clause attempts to throw any C++ exception, the
%% %%             behaviour is undefined.
%% \end{description}
%% 
%% \returns
%% \begin{description}
%%     \item[---] None: \unwindfib does not return
%% \end{description}
%% 
%% \except
%% \begin{description}
%%     \item[---] None catchable by C++
%% \end{description}

\abschnitt{Feature-test Macro}
\bfs{Add} a new feature-test macro to §17.3.2 \stdclause{version.syn}:

\cpp{#define \__cpp\_lib\_fiber\_context 202XXXL // also in <fiber\_context>}
